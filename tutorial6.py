# -*- coding: utf-8 -*-
"""tutorial6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SL9UFmILLB2OkRb1mk6rxp0yIStAUA5w
"""

# To transform your features into new values
from sklearn import preprocessing

# Import train_test_split function
from sklearn.model_selection import train_test_split

# To construct and plot decision trees
from sklearn import tree
from matplotlib import pyplot as plt

# Import Decision Tree Classifier to predict loan approval status
from sklearn.tree import DecisionTreeClassifier

# Import Decision Tree Regressor to predict maximum loan amount
from sklearn.tree import DecisionTreeRegressor


#To optimise the Decision Tree model's hyperparameters
from sklearn.model_selection import GridSearchCV

#Import scikit-learn metrics module for classification and regression performance metrics
from sklearn import metrics

# To create and plot the confusion matrix
from sklearn.metrics import confusion_matrix
from sklearn.metrics import ConfusionMatrixDisplay

# To produce the classification metrics report
from sklearn.metrics import classification_report

# To create, calculate and plot the RoC curve
from sklearn.metrics import RocCurveDisplay

import pandas as pd

data = pd.read_csv('/content/loan_approval_data.csv')

# To expand the truncation of rows and columns
pd.set_option('display.max_rows', 3000)
pd.set_option('display.max_columns', 3000)
pd.set_option('display.width', 150)

# To expand e scientific notation
pd.set_option('display.float_format', '{:.2f}'.format)

data.shape

data.info()

data.describe(include='all').transpose()

import plotly.express as px

loan_approval_status_fig = px.histogram(data, x='loan_approval_status')
loan_max_amount_fig = px.histogram(data, x='max_allowed_loan')
loan_approval_status_fig.show()
loan_max_amount_fig.show()

Age_fig = px.box(data, x='age')
Age_fig.show()

Income_fig = px.box(data, x='income')
Income_fig.show()

emp_fig = px.box(data, x='emplyment_length')
emp_fig.show()

loan_fig = px.box(data, x='loan_amount')
loan_fig.show()

interest_fig = px.box(data, x='loan_interest_rate')
interest_fig.show()

income_fig = px.box(data, x='loan_income_ratio')
income_fig.show()

creHis_fig = px.box(data, x='credit_history_length')
creHis_fig.show()

max_fig = px.box(data, x='max_allowed_loan')
max_fig.show()

data.isna().sum()/len(data)*100

print('home_ownership categories are:', data['home_ownership'].unique())
print('loan_intent categories are:',data['loan_intent'].unique())
print('payment_default_on_file categories are:',data['payment_default_on_file'].unique())

#Create a function to find the outlier data points
def find_outliers_IQR(data):
  q1=data.quantile(0.25)
  q3=data.quantile(0.75)
  IQR=q3-q1
  outliers = data[((data<(q1-1.5*IQR)) | (data>(q3+1.5*IQR)))]
  return outliers

# Find the outlier data points in the age variable
age_outliers = find_outliers_IQR(data['age'])
print("number of outliers: "+ str(len(age_outliers)))
print("max outlier value: "+ str(age_outliers.max()))
print("min outlier value: "+ str(age_outliers.min()))
age_outliers.sort_values(ascending=False)

# Find the outlier data points in emplyment_length variable
emplyment_length_outliers = find_outliers_IQR(data['emplyment_length'])
print("number of outliers: "+ str(len(emplyment_length_outliers)))
print("max outlier value: "+ str(emplyment_length_outliers.max()))
print("min outlier value: "+ str(emplyment_length_outliers.min()))
emplyment_length_outliers.sort_values(ascending=False)

# Find the outlier data points in loan_interest_rate variable
loan_interest_rate_outliers = find_outliers_IQR(data['loan_interest_rate'])
print("number of outliers: "+ str(len(loan_interest_rate_outliers)))
print("max outlier value: "+ str(loan_interest_rate_outliers.max()))
print("min outlier value: "+ str(loan_interest_rate_outliers.min()))
loan_interest_rate_outliers.sort_values(ascending=True)

# Find the outlier data points in max_allowed_loan variable
max_allowed_loan_outliers = find_outliers_IQR(data['max_allowed_loan'])
print("number of outliers: "+ str(len(max_allowed_loan_outliers)))
print("max outlier value: "+ str(max_allowed_loan_outliers.max()))
print("min outlier value: "+ str(max_allowed_loan_outliers.min()))
max_allowed_loan_outliers.sort_values(ascending=True)

data.drop(data.index[[39792, 9479, 6008, 56728, 8998, 0, 1, 2]], inplace=True)

age_fig = px.box(data, x='age')
emplyment_length_fig = px.box(data, x='emplyment_length')
loan_interest_rate_fig = px.box(data, x='loan_interest_rate')
max_allowed_loan_fig = px.box(data, x='max_allowed_loan')

age_fig.show()
emplyment_length_fig.show()
loan_interest_rate_fig.show()
max_allowed_loan_fig.show()

# Import label encoder
from sklearn import preprocessing
label_encoder = preprocessing.LabelEncoder()

# Encode the categories in each object variable to a numeric form
data['home_ownership']= label_encoder.fit_transform(data['home_ownership'])
data['loan_intent']= label_encoder.fit_transform(data['loan_intent'])
data['payment_default_on_file']= label_encoder.fit_transform(data['payment_default_on_file'])

# Check the categories' labels after the label encoding transformation is completed
print("New labels for home_ownership are: ", data['home_ownership'].unique())
print("New labels for loan_intent are: ", data['loan_intent'].unique())
print("New labels for payment_default_on_file are: ", data['payment_default_on_file'].unique())

# Calculate the mean of each variable
Mean_age = data['age'].mean()
Mean_loan_interest_rate = data['loan_interest_rate'].mean()

# use the mean to impute the missing values in each variable
data['age'].fillna(Mean_age, inplace=True)
data['loan_interest_rate'].fillna(Mean_loan_interest_rate, inplace=True)

data.isna().sum()/len(data)*100

data.to_csv(r'/content/prepared_loan_approval_data.csv', index=False)

#Load your prepared dataset as df
df = pd.read_csv('/content/prepared_loan_approval_data.csv')

# Keep the target for classification and drop only the regression target max_allowed_loan
df.drop('max_allowed_loan',axis=1, inplace=True)
df.head()

#Save your classification dataset under the name loan_approval_status_data
df.to_csv(r'/content/loan_approval_status_data.csv', index=False)

#load your fully prepared dataset as df2
df2=pd.read_csv('/content/prepared_loan_approval_data.csv')

# Filter approved applicants (loan_approval_status for status = 0) in a new data frame called approved_loan_applicants
approved_loan_applicants =  df2[(df2.loan_approval_status < 1)]

# Check the basic stats to observe only approved applicants remain
approved_loan_applicants.describe().transpose()

# Drop the loan_approval_status variable from the data frame
approved_loan_applicants.drop('loan_approval_status',axis=1, inplace=True)
approved_loan_applicants.head()

df_loan_status = pd.read_csv('/content/loan_approval_status_data.csv')
df_loan_status.head()

# The inputs are all the variables in the data assigned to X except the target and id, hence dropped
X = df_loan_status.drop(['loan_approval_status', 'id'], axis=1)

# The target output is assigned to y
y = df_loan_status['loan_approval_status']

# Split the dataset in 60% Training and 40% Test with class stratification
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, random_state=43, stratify=y)

# Build a fully grown decision tree clf
clf = DecisionTreeClassifier()
clf.fit(X_train, y_train)

#To make predictions on the test set, ues the predict method:
y_pred_clf = clf.predict(X_test)

#You can size your plot then plot the fully grown classification tree
Unpruned_Tree_figure = plt.figure(figsize=(200,200))
DT_Graph = tree.plot_tree(clf, feature_names=list(X_train.columns), class_names = ['0','1'], filled=True)

# To find the full depth of the decision tree
print(clf.tree_.max_depth)

#To save the DT graph
Unpruned_Tree_figure.savefig("fully_grown_decistion_tree.svg")

# Create Decision Tree classifer object
clf_pruned = DecisionTreeClassifier(max_depth = 4)

# Train Decision Tree Classifer
clf_pruned = clf_pruned.fit(X_train,y_train)

#Predict the response for test dataset
y_pred_clf_pruned = clf_pruned.predict(X_test)

#You can size your plot then plot the pruned classification tree
pruned_Tree_figure = plt.figure(figsize=(200,200))
DT_Graph = tree.plot_tree(clf_pruned, feature_names=list(X_train.columns), class_names = ['0','1'], filled=True)

#To save the pruned DT graph
pruned_Tree_figure.savefig("pruned_decistion_tree.png")

# Construct and plot the confusion matrix for the fuly-grown tree (clf model)
clf_cm_test = confusion_matrix(y_test, y_pred_clf, labels=clf.classes_ )
disp = ConfusionMatrixDisplay(clf_cm_test,display_labels=clf.classes_   )
disp.plot(values_format = '.0f') # value_format = .0f expands the scientific notation e inside the confusion matrix

# Produce the classification report for the fuly-grown tree (clf model)
print("clf fully grown tree report \n", classification_report(y_test, y_pred_clf))

# Plot the ROC curve for the fully-grown treen
clf_Roc = RocCurveDisplay.from_estimator(clf, X_test, y_test)

# Construct and plot the confusion matrix for the pruned tree (clf_pruned model)
clf_pruned_cm_test = confusion_matrix(y_test, y_pred_clf_pruned, labels = clf_pruned.classes_)
disp = ConfusionMatrixDisplay(clf_pruned_cm_test,display_labels = clf_pruned.classes_)
disp.plot(values_format = '.0f')

# Produce the classification report for the prunded tree (clf_pruned model)
print("clf_pruned tree report \n", classification_report(y_test, y_pred_clf_pruned))

# Plot the ROC curve for the pruned treen
clf_pruned_Roc = RocCurveDisplay.from_estimator(clf_pruned, X_test, y_test)

#testttt